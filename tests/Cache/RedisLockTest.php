<?php

declare(strict_types=1);

namespace Hypervel\Tests\Cache;

use Hypervel\Cache\RedisLock;
use Hypervel\Redis\Redis;
use Hypervel\Tests\TestCase;
use Mockery as m;
use RuntimeException;

/**
 * @internal
 * @coversNothing
 */
class RedisLockTest extends TestCase
{
    public function testAcquireWithExpirationUsesSETWithNXAndEX(): void
    {
        $redis = m::mock(Redis::class);
        $redis->shouldReceive('set')
            ->once()
            ->with('lock:foo', m::type('string'), ['EX' => 60, 'NX'])
            ->andReturn(true);

        $lock = new RedisLock($redis, 'lock:foo', 60);

        $this->assertTrue($lock->acquire());
    }

    public function testAcquireWithExpirationReturnsFalseWhenLockExists(): void
    {
        $redis = m::mock(Redis::class);
        $redis->shouldReceive('set')
            ->once()
            ->with('lock:foo', m::type('string'), ['EX' => 60, 'NX'])
            ->andReturn(false);

        $lock = new RedisLock($redis, 'lock:foo', 60);

        $this->assertFalse($lock->acquire());
    }

    public function testAcquireWithoutExpirationUsesSETNX(): void
    {
        $redis = m::mock(Redis::class);
        $redis->shouldReceive('setnx')
            ->once()
            ->with('lock:foo', m::type('string'))
            ->andReturn(true);

        $lock = new RedisLock($redis, 'lock:foo', 0);

        $this->assertTrue($lock->acquire());
    }

    public function testAcquireWithoutExpirationReturnsFalseWhenLockExists(): void
    {
        $redis = m::mock(Redis::class);
        $redis->shouldReceive('setnx')
            ->once()
            ->with('lock:foo', m::type('string'))
            ->andReturn(false);

        $lock = new RedisLock($redis, 'lock:foo', 0);

        $this->assertFalse($lock->acquire());
    }

    public function testReleaseUsesLuaScriptToAtomicallyCheckOwnership(): void
    {
        $redis = m::mock(Redis::class);
        $redis->shouldReceive('eval')
            ->once()
            ->with(m::type('string'), 1, 'lock:foo', 'owner123')
            ->andReturn(1);

        $lock = new RedisLock($redis, 'lock:foo', 60, 'owner123');

        $this->assertTrue($lock->release());
    }

    public function testReleaseReturnsFalseWhenNotOwner(): void
    {
        $redis = m::mock(Redis::class);
        $redis->shouldReceive('eval')
            ->once()
            ->with(m::type('string'), 1, 'lock:foo', 'owner123')
            ->andReturn(0);

        $lock = new RedisLock($redis, 'lock:foo', 60, 'owner123');

        $this->assertFalse($lock->release());
    }

    public function testForceReleaseDeletesKeyRegardlessOfOwnership(): void
    {
        $redis = m::mock(Redis::class);
        $redis->shouldReceive('del')
            ->once()
            ->with('lock:foo');

        $lock = new RedisLock($redis, 'lock:foo', 60);

        $lock->forceRelease();
    }

    public function testOwnerReturnsTheOwnerIdentifier(): void
    {
        $redis = m::mock(Redis::class);

        $lock = new RedisLock($redis, 'lock:foo', 60, 'my-owner-id');

        $this->assertSame('my-owner-id', $lock->owner());
    }

    public function testOwnerIsAutoGeneratedWhenNotProvided(): void
    {
        $redis = m::mock(Redis::class);

        $lock = new RedisLock($redis, 'lock:foo', 60);

        $this->assertNotEmpty($lock->owner());
        $this->assertIsString($lock->owner());
    }

    public function testGetCallsAcquireAndExecutesCallbackOnSuccess(): void
    {
        $redis = m::mock(Redis::class);
        $redis->shouldReceive('set')
            ->once()
            ->with('lock:foo', m::type('string'), ['EX' => 60, 'NX'])
            ->andReturn(true);
        $redis->shouldReceive('eval')
            ->once()
            ->andReturn(1);

        $lock = new RedisLock($redis, 'lock:foo', 60);

        $result = $lock->get(fn () => 'callback-result');

        $this->assertSame('callback-result', $result);
    }

    public function testGetReturnsFalseWhenLockNotAcquired(): void
    {
        $redis = m::mock(Redis::class);
        $redis->shouldReceive('set')
            ->once()
            ->with('lock:foo', m::type('string'), ['EX' => 60, 'NX'])
            ->andReturn(false);

        $lock = new RedisLock($redis, 'lock:foo', 60);

        $result = $lock->get(fn () => 'callback-result');

        $this->assertFalse($result);
    }

    public function testGetReleasesLockAfterCallbackEvenOnException(): void
    {
        $redis = m::mock(Redis::class);
        $redis->shouldReceive('set')
            ->once()
            ->andReturn(true);
        $redis->shouldReceive('eval')
            ->once()
            ->andReturn(1);

        $lock = new RedisLock($redis, 'lock:foo', 60);

        $this->expectException(RuntimeException::class);

        $lock->get(function () {
            throw new RuntimeException('test exception');
        });
    }
}
